<canvas></canvas>
<script>
    function Rect(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    Rect.prototype.fits_in = function(outer)
    {
        return outer.w >= this.w && outer.h >= this.h;
    }

    Rect.prototype.same_size_as = function(other)
    {
        return this.w == other.w && this.h == other.h;
    }

    function Node()
    {
        this.left = null;
        this.right = null;
        this.rect = null;
        this.filled = false;
    }

    Node.prototype.insert_rect = function(rect)
    {
        //document.write('1<br>');
        if(this.left != null)
            return this.left.insert_rect(rect) || this.right.insert_rect(rect);

        //document.write('2<br>');
        if(this.filled)
            return null;

        //document.write('3 ' + this.rect + ' ' + rect + '<br>');
        if(!rect.fits_in(this.rect))
            return null;

        //document.write('4<br>');
        if(rect.same_size_as(this.rect))
        {
            //document.write('filled<br>');
            this.filled = true;
            return this;
        }

        this.left = new Node();
        this.right = new Node();

        var width_diff = this.rect.w - rect.w;
        var height_diff = this.rect.h - rect.h;

        var me = this.rect;

        //document.write('5<br>');
        if(width_diff > height_diff)
        {
            // split literally into left and right, putting the rect on the left.
            this.left.rect = new Rect(me.x, me.y, rect.w, me.h);
            this.right.rect = new Rect(me.x + rect.w, me.y, me.w - rect.w, me.h);
            //document.write('splitting horizontally<br>');
        }
        else
        {
            // split into top and bottom, putting rect on top.
            this.left.rect = new Rect(me.x, me.y, me.w, rect.h);
            this.right.rect = new Rect(me.x, me.y + rect.h, me.w, me.h - rect.h);
            //document.write('splitting vertically<br>');
        }

        return this.left.insert_rect(rect);
    }

    var random_color = function()
    {
        var r = 32 + Math.floor(Math.random() * 192);
        var g = 32 + Math.floor(Math.random() * 192);
        var b = 32 + Math.floor(Math.random() * 192);
        var colors = [0, 0, 0];
        colors[Math.min(2, Math.floor(Math.random() * 3))] = 32 + Math.floor(Math.random() * 192);
        colors[Math.min(2, Math.floor(Math.random() * 3))] = 32 + Math.floor(Math.random() * 192);
        return 'rgb('+colors[0]+','+colors[1]+','+colors[2]+')';
    }

    var width = 1000;
    var height = 1000;

    var max_rect_width = 25;
    var max_rect_height = 25;

    var start_node = new Node();
    start_node.rect = new Rect(0, 0, width, height);

    var canvas = document.getElementsByTagName('canvas')[0];
    canvas.width = width;
    canvas.height = height;

    var ctx = canvas.getContext('2d');

    var start = new Date();
    while(true)
    {
        var rect = new Rect(0, 0, // x/y don't matter here; it has no position yet
            Math.floor(Math.random() * max_rect_width),
            Math.floor(Math.random() * max_rect_height));
        //document.write('<b>box ' + i + '.<br>');
        var node = start_node.insert_rect(rect);
        if(node)
        {
            var r = node.rect;
            ctx.fillStyle = random_color();
            ctx.fillRect(r.x, r.y, r.w, r.h);
            //document.write('<br>fillRect('+r.x+', '+r.y+', '+r.w+', '+r.h+');');
        }
        else
            break;
    }
    var end = new Date();

    document.write(end.getTime() - start.getTime());
</script>
